* 9.1 Lists
* 9.2 The list datatype

The list datatype is defined like: ~data [] a = [] | a : [a]~. Sum datatypes haven't been introduced
yet.

* 9.3 Pattern matching on lists

Naive pattern matching on lists doesn't take into account an empty list, so Maybe is needed:

#+BEGIN_SRC haskell :tangle safetail.hs
  safeTail         :: [a] -> Maybe [a]
  safeTail []      = Nothing
  safeTail (x:[])  = Nothing
  safeTail (_:xs)  = Just xs
#+END_SRC

* 9.4 List's syntactic sugar

Note that
#+BEGIN_SRC haskell
[1, 2, 3] ++ [4]
#+END_SRC

is identical to

#+BEGIN_SRC haskell
(1 : 2 : 3 : []) ++ 4 : []
#+END_SRC

When talking of lists, some terms:

** "cons cells"
cons cells are the list datatype's second constructor, ~a : [a]~, the result of recursively prepending
a value to "more list". The cons cell is a conceptual space that values may inhabit.

** spine
spine is the connective structure that holds the cons cells together and in place

* 9.5 Using ranges to construct lists

#+BEGIN_SRC haskell
[1,3..10]

-- is the same as

enumFromThenTo 1 3 10
#+END_SRC

for all instances of the Enum typeclass

** Exercise: EnumFromTo

I think I probably misunderstood what this question was asking for. They wanted functions for
all four types, Bool, Ordering, Int, Char, but they're all instances of the Enum and Eq
typeclasses, so the eftEnumEq function seems to do what I think they're asking for, but then I
don't understand why they asked for all four. I assume I misunderstood.

#+BEGIN_SRC haskell :tangle 9.5-enumFromTo.hs
  eftEnumEq :: (Enum a, Eq a) => a -> a -> [a]
  eftEnumEq start stop = go start stop []
    where go curr stop retlist
           | curr == stop  = retlist ++ [curr]
           | otherwise     = go (succ curr) stop (retlist ++ [curr])

  eftBool :: Bool -> Bool -> [Bool]
  eftBool  = eftEnumEq

  eftOrd :: Ordering -> Ordering -> [Ordering]
  eftOrd  = eftEnumEq

  eftInt :: Int -> Int -> [Int]
  eftInt =  eftEnumEq

  eftChar :: Char -> Char -> [Char]
  eftChar  = eftEnumEq
#+END_SRC

* 9.6 Extracting portions of lists

~take n a~ returns the first n elements of List a as a list

~drop n a~ returns the last (length a) - n elements of List a as a list (i.e. drops the first n elements and
returns the remaining ones)

~splitat n a~ returns two-tuple of lists from list a, split at the nth position

takeWhile and dropWhile do similar things, but as higher-order functions with ~a -> Bool~ "selection" functions
as arguments:

#+BEGIN_EXAMPLE
Prelude> takeWhile (=='a') [a..z]
"a"
#+END_EXAMPLE

** Exercises: Thy Fearful Symmetry

*** 1.

My solution seems needlessly complicated. There's probably a solution that involves not having
to use both dropWhile and takeWhile in the same go statement

#+BEGIN_SRC haskell :tangle 9.6.symmetry01.hs
  myWords :: [Char] -> [[Char]]
  myWords sentence = go sentence []
    where go sentence retwords
           | length sentence > 0 = go (drop 1 $ dropWhile (/=' ') sentence)
                                      (retwords ++ [takeWhile (/=' ') sentence])
           | otherwise           = retwords
#+END_SRC

*** 2.

#+BEGIN_SRC haskell :tangle 9.6.symmetry02.hs
  module PoemLines where

  firstSen = "Tyger Tyger, burning bright\n"
  secondSen = "In the forests of the night\n"
  thirdSen = "What immortal hand or eye\n"
  fourthSen = "Could frame thy fearful\
              \ symmetry?"
  sentences = firstSen ++ secondSen
           ++ thirdSen ++ fourthSen

  -- putStrLn sentences -- should print
  -- Tyger Tyger, burning bright
  -- In the forests of the night
  -- What immortal hand or eye
  -- Could frame thy fearful symmetry?


  -- Implement this
  myLines :: String -> [String]
  myLines longstring = go longstring []
    where go longstring lines
           | length longstring > 0 = go (drop 1 $ dropWhile (/='\n') longstring)
                                        (lines ++ [takeWhile (/='\n') longstring])
           | otherwise             = lines

  -- What we want 'myLines sentences' to equal
  shouldEqual =
    [ "Tyger Tyger, burning bright"
    , "In the forests of the night"
    , "What immortal hand or eye"
    , "Could frame thy fearful symmetry?"
    ]

  -- The main function here is a small test to ensure you've written your function
  -- correctly.
  main :: IO ()
  main =
    print $
    "Are they equal? "
    ++ show (myLines sentences
             == shouldEqual)
#+END_SRC

*** 3. Left as an exercise to the reader's reader.

* 9.7 List comprehensions

#+BEGIN_EXAMPLE
[ x^2 | x <- [1..10]]
#+END_EXAMPLE

 or with predicates:

#+BEGIN_EXAMPLE
[x^2 | x <- [1..10], rem x 2 == 0]
#+END_EXAMPLE

multiple generators:

#+BEGIN_EXAMPLE
[x^y | x <- [1..5], y <- [2,3]]
#+END_EXAMPLE

multiple predicates!:

#+BEGIN_EXAMPLE
[x^y |
 x <- [1..5],
 y <- [2, 3],
 x^y < 200]
#+END_EXAMPLE

it can zip up multiple generators of different lengths and types into tuples:

#+BEGIN_EXAMPLE
Prelude> :{
Prelude| [(x, y) |
Prelude| x <- [1, 2, 3],
Prelude| y <- [6, 7]]
Prelude| :}
[(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
#+END_EXAMPLE

** Exercises: Comprehend Thy Lists

#+BEGIN_EXAMPLE
-- let mySqr = [x^2 | x <- [1..10]]    == [1,4,9,16,25,36,49,64,81,100]

[x | x <- mySqr, rem x 2 == 0] == [4,16,36,64,100]
[(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
...
#+END_EXAMPLE

** Exercises: Square Cube

#+BEGIN_SRC haskell :tangle 9.7-square-cube.hs
mySqr  = [x^2 | x <- [1..5]]
myCube = [x^3 | x <- [1..5]]

myTuples = [(x, y) | x <- mySqr, y <- myCube]

myTuplesLtFifty = [(x, y) | x <- mySqr, y <- myCube, x < 50 && y < 50]
#+END_SRC
* 9.8 Spines and nonstrict evaluation

** Exercises: Bottom Madness

*** 1. ~[x^y | x <- [1..5], y <- [2, undefined]]~
will bottom, as x^undefined is evaluated

*** 2. ~take 1 $ [x^y | x <- [1..5], y <- [2, undefined]]~
will return ~[1]~, because only the first cons cell is evaluated, which is 1^2=1

*** 3. ~sum [1, undefined, 3]~
will bottom since all the cons cells are evaluated in the summation

*** 4. ~length [1, 2, undefined]~
will return 3 because only the spine is evaluated (is "evaluated" the right word?)

*** 5. ~length $ [1, 2, 3] ++ undefined~
will bottom, I think because you can't add an element to a list. adding [undefined] to this
would make it work.

*** 6. ~take 1 $ filter even [1, 2, 3, undefined]~
will return ~[2]~ because the filter evaluation stops when the first even number, 2 is found

*** 7. ~take 1 $ filter even [1, 3, undefined]~
will bottom as all cons cells are evaluated trying to find the not present even value

*** 8. ~take 1 $ filter odd [1, 3, undefined]~
will return ~[1]~. See (6) above

*** 9. ~take 2 $ filter odd [1, 3, undefined]~
will return ~[1, 3]~ for the same reason as (6) and (8) above

*** 10. ~take 3 $ filter odd [1, 3, undefined]~
will bottom. see (7) above

** Intermission: Is it in normal form?

Are the following in normal form (NF), weak head normal form (WHNF), or nothing

*** 1. ~[1, 2, 3, 4, 5]~
normal form

*** 2. ~1 : 2 : 3 : 4 : _~
whnf. the spine is fully evaluated, but the last cons cell is still unevaluated

*** 3. ~enumFromTo 1 10~
nothing. the outermost component of this expression is an unapplied function evaluation

*** 4. ~length [1, 2, 3, 4, 5]~
nothing. same as (3)

*** 5. ~sum (enumFromTo 1 10)~
nothing. same as (3) and (4)

*** 6. ~['a'..'m'] ++ ['n'..'z']~
nothing. same as (3), (4), and (5)

*** 7 ~(_, b)~
I think it's whnf, but @larrybotha thinks it's nf and he's smarter than me. TODO - look into
this

* 9.9 Transforming lists of values
